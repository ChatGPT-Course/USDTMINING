
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crash Game</title>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --main-bg: #181c27;
      --panel-bg: #23283a;
      --accent: #ffb300;
      --danger: #ff3b3b;
      --success: #4caf50;
      --text: #fff;
      --text-muted: #b0b8d1;
      --border: #2c3145;
      --shadow: 0 4px 24px rgba(0,0,0,0.3);
      --radius: 18px;
      --transition: 0.2s cubic-bezier(.4,0,.2,1);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      background: var(--main-bg);
      color: var(--text);
      font-family: 'Montserrat', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .centered {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    .btn {
      background: var(--accent);
      color: #222;
      border: none;
      border-radius: var(--radius);
      padding: 18px 48px;
      font-size: 1.5rem;
      font-weight: 700;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: background var(--transition), transform var(--transition);
      margin: 12px 0;
    }
    .btn:disabled {
      background: #b0b8d1;
      color: #444;
      cursor: not-allowed;
      opacity: 0.7;
    }
    .btn:hover:enabled {
      background: #ffd54f;
      transform: translateY(-2px) scale(1.03);
    }
    .game-container {
      background: var(--panel-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 32px 24px 24px 24px;
      max-width: 900px;
      width: 100%;
      margin: 32px auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }
    .balance {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 18px;
      letter-spacing: 1px;
    }
    .crash-graph {
      width: 100%;
      max-width: 700px;
      height: 320px;
      background: #1a1e2d;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin-bottom: 24px;
      position: relative;
      overflow: hidden;
      border: 2px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .crash-multiplier {
      position: absolute;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2.8rem;
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 2px 12px #000a;
      z-index: 2;
      letter-spacing: 2px;
      pointer-events: none;
      user-select: none;
    }
    .bet-panel {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 18px;
      margin-bottom: 18px;
      flex-wrap: wrap;
    }
    .bet-panel input[type="number"] {
      background: #23283a;
      color: var(--text);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      padding: 10px 18px;
      font-size: 1.1rem;
      width: 110px;
      outline: none;
      transition: border var(--transition);
    }
    .bet-panel input[type="number"]:focus {
      border: 2px solid var(--accent);
    }
    .bet-panel .btn {
      padding: 12px 28px;
      font-size: 1.1rem;
      margin: 0;
    }
    .auto-cashout {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--text-muted);
      font-size: 1rem;
    }
    .auto-cashout input[type="number"] {
      width: 70px;
      padding: 6px 10px;
      font-size: 1rem;
    }
    .players-list {
      background: #23283a;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 12px 18px;
      margin-top: 18px;
      width: 100%;
      max-width: 700px;
      min-height: 80px;
    }
    .players-list-title {
      font-size: 1.1rem;
      color: var(--text-muted);
      margin-bottom: 8px;
      font-weight: 700;
    }
    .players-table {
      width: 100%;
      border-collapse: collapse;
    }
    .players-table th, .players-table td {
      padding: 6px 8px;
      text-align: left;
      font-size: 1rem;
    }
    .players-table th {
      color: var(--text-muted);
      font-weight: 700;
    }
    .players-table tr {
      border-bottom: 1px solid var(--border);
    }
    .players-table tr:last-child {
      border-bottom: none;
    }
    .status-bar {
      margin: 12px 0 0 0;
      font-size: 1.1rem;
      color: var(--text-muted);
      text-align: center;
      min-height: 28px;
    }
    .crash {
      color: var(--danger);
      font-weight: 700;
      font-size: 2.2rem;
      text-shadow: 0 2px 12px #000a;
      margin-top: 12px;
      animation: crash-pop 0.7s cubic-bezier(.4,0,.2,1);
    }
    .waiting-round {
      color: var(--accent);
      font-size: 1.5rem;
      font-weight: 700;
      text-align: center;
      width: 100%;
      padding: 60px 0;
      letter-spacing: 1px;
    }
    @keyframes crash-pop {
      0% { transform: scale(0.7); opacity: 0; }
      60% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    @media (max-width: 900px) {
      .game-container { max-width: 99vw; padding: 12px 2vw; }
      .crash-graph, .players-list { max-width: 99vw; }
    }
    @media (max-width: 600px) {
      .crash-graph { height: 180px; }
      .crash-multiplier { font-size: 1.7rem; }
      .bet-panel { flex-direction: column; gap: 10px; }
      .players-list { padding: 8px; }
    }
    .you {
      background: rgba(255, 179, 0, 0.08);
    }
  </style>
</head>
<body>
  <div id="main-menu" class="centered">
    <h1 style="font-size:2.7rem; font-weight:800; margin-bottom:32px; letter-spacing:2px;">Crash Game</h1>
    <button class="btn" id="play-btn">Играть в краш</button>
  </div>
  <div id="game" style="display:none;">
    <div class="game-container">
      <div class="balance" id="balance">Баланс: 100₽</div>
      <div class="crash-graph" id="crash-graph">
        <div class="crash-multiplier" id="multiplier">1.00x</div>
        <canvas id="graph-canvas" width="700" height="320" style="width:100%;height:100%;position:absolute;top:0;left:0;"></canvas>
        <div id="waiting-round" class="waiting-round" style="display:none;">Ожидание нового раунда</div>
      </div>
      <div class="bet-panel">
        <input type="number" id="bet-amount" min="10" max="10000" step="1" value="10" placeholder="Ставка (₽)">
        <div class="auto-cashout">
          Автостоп:
          <input type="number" id="auto-cashout" min="1.01" max="100" step="0.01" value="2.00">
          x
        </div>
        <button class="btn" id="bet-btn">Сделать ставку</button>
        <button class="btn" id="cashout-btn" style="display:none;background:var(--success);color:#fff;">Забрать</button>
      </div>
      <div class="status-bar" id="status-bar">Ожидание следующего раунда...</div>
      <div id="crash-msg" class="crash" style="display:none;">CRASH!</div>
      <div class="players-list">
        <div class="players-list-title">Игроки онлайн и их ставки</div>
        <table class="players-table" id="players-table">
          <thead>
            <tr>
              <th>Игрок</th>
              <th>Ставка</th>
              <th>Автостоп</th>
              <th>Статус</th>
              <th>Выигрыш</th>
            </tr>
          </thead>
          <tbody id="players-tbody">
            <!-- Игроки будут добавляться динамически -->
          </tbody>
        </table>
      </div>
    </div>
  </div>
  <script>
    // --- Telegram mini app user ---
    let tgUser = null;
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
      tgUser = Telegram.WebApp.initDataUnsafe.user;
    }
    // Fallback for local testing
    if (!tgUser) {
      tgUser = {
        id: localStorage.getItem('tg_id') || 'tg_' + Math.floor(Math.random()*1000000),
        username: localStorage.getItem('tg_username') || 'Гость_' + Math.floor(Math.random()*10000),
        first_name: 'Гость'
      };
      localStorage.setItem('tg_id', tgUser.id);
      localStorage.setItem('tg_username', tgUser.username);
    }
    const userId = String(tgUser.id);
    const userName = tgUser.username ? '@' + tgUser.username : tgUser.first_name || 'Гость';

    // --- Firebase config ---
    const firebaseConfig = {
      apiKey: "AIzaSyCMos6Y7C-krTLuKCI4VJG-TFLo6QI--k8",
      authDomain: "vrot-x-7a48f.firebaseapp.com",
      databaseURL: "https://vrot-x-7a48f-default-rtdb.firebaseio.com",
      projectId: "vrot-x-7a48f",
      storageBucket: "vrot-x-7a48f.appspot.com",
      messagingSenderId: "622297225288",
      appId: "1:622297225288:web:5df6a5b02ffddedd96e07d"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // --- Баланс ---
    let balance = parseFloat(localStorage.getItem('crash_balance_' + userId));
    if (isNaN(balance)) {
      balance = 100;
      localStorage.setItem('crash_balance_' + userId, balance);
    }
    function updateBalanceUI() {
      document.getElementById('balance').textContent = `Баланс: ${balance.toFixed(2)}₽`;
    }
    updateBalanceUI();

    // --- Main menu logic ---
    document.getElementById('play-btn').onclick = () => {
      document.getElementById('main-menu').style.display = 'none';
      document.getElementById('game').style.display = 'block';
      joinOnline();
    };

    // --- Online players ---
    function joinOnline() {
      const onlineRef = db.ref('crash/online/' + userId);
      onlineRef.set({
        name: userName,
        ts: firebase.database.ServerValue.TIMESTAMP
      });
      onlineRef.onDisconnect().remove();
    }

    // --- Game state ---
    let gameState = {
      status: 'waiting', // waiting | starting | started | crashed
      startTime: 0,
      crashAt: 0,
      multiplier: 1.0,
      roundId: '',
      players: {},
      nextStart: 0
    };
    let myBet = null;
    let myAutoCashout = 2.00;
    let myCashout = null;
    let graphData = [];
    let graphAnimId = null;
    let joinedInRound = false;

    // --- UI Elements ---
    const multiplierEl = document.getElementById('multiplier');
    const statusBar = document.getElementById('status-bar');
    const crashMsg = document.getElementById('crash-msg');
    const betBtn = document.getElementById('bet-btn');
    const cashoutBtn = document.getElementById('cashout-btn');
    const betAmountInput = document.getElementById('bet-amount');
    const autoCashoutInput = document.getElementById('auto-cashout');
    const playersTbody = document.getElementById('players-tbody');
    const graphCanvas = document.getElementById('graph-canvas');
    const ctx = graphCanvas.getContext('2d');
    const waitingRoundDiv = document.getElementById('waiting-round');

    // --- Bet logic ---
    betBtn.onclick = () => {
      const bet = parseFloat(betAmountInput.value);
      const auto = parseFloat(autoCashoutInput.value);
      if (isNaN(bet) || bet < 10 || bet > balance) {
        alert('Некорректная сумма ставки!');
        return;
      }
      if (isNaN(auto) || auto < 1.01 || auto > 100) {
        alert('Некорректный автостоп!');
        return;
      }
      if (gameState.status !== 'waiting' && gameState.status !== 'starting') {
        alert('Ставки принимаются только до начала раунда!');
        return;
      }
      myBet = bet;
      myAutoCashout = auto;
      betAmountInput.disabled = true;
      autoCashoutInput.disabled = true;
      betBtn.disabled = true;
      betBtn.textContent = 'Ставка сделана';
      db.ref('crash/rounds/' + gameState.roundId + '/players/' + userId).set({
        name: userName,
        bet: bet,
        auto: auto,
        status: 'playing',
        cashout: null
      });
    };
    cashoutBtn.onclick = () => {
      if (gameState.status !== 'started' || !myBet || myCashout) return;
      const cashoutAt = gameState.multiplier;
      myCashout = cashoutAt;
      db.ref('crash/rounds/' + gameState.roundId + '/players/' + userId + '/cashout').set(cashoutAt);
      db.ref('crash/rounds/' + gameState.roundId + '/players/' + userId + '/status').set('cashed');
      cashoutBtn.disabled = true;
      cashoutBtn.textContent = 'Забрано!';
    };
    autoCashoutInput.oninput = () => {
      let v = parseFloat(autoCashoutInput.value);
      if (isNaN(v) || v < 1.01) v = 1.01;
      if (v > 100) v = 100;
      autoCashoutInput.value = v.toFixed(2);
      myAutoCashout = v;
    };

    // --- Game loop ---
    function listenGameState() {
      db.ref('crash/state').on('value', snap => {
        const state = snap.val();
        if (!state) return;
        const prevRoundId = gameState.roundId;
        gameState.status = state.status;
        gameState.startTime = state.startTime;
        gameState.crashAt = state.crashAt;
        gameState.multiplier = state.multiplier;
        gameState.roundId = state.roundId;
        gameState.nextStart = state.nextStart || 0;
        if (prevRoundId !== state.roundId) {
          joinedInRound = false;
          myBet = null;
          myCashout = null;
          betAmountInput.disabled = false;
          autoCashoutInput.disabled = false;
          betBtn.disabled = false;
          betBtn.textContent = 'Сделать ставку';
        }
        updateGameUI();
        listenPlayers();
      });
    }
    function listenPlayers() {
      db.ref('crash/rounds/' + gameState.roundId + '/players').on('value', snap => {
        gameState.players = snap.val() || {};
        updatePlayersTable();
        // Если игрок только что присоединился в уже идущем раунде
        if (!joinedInRound && (gameState.status === 'started' || gameState.status === 'crashed')) {
          if (!gameState.players[userId]) {
            joinedInRound = true;
            showWaitingRound();
          }
        }
      });
    }
    function updateGameUI() {
      if (gameState.status === 'waiting' || gameState.status === 'starting') {
        waitingRoundDiv.style.display = 'none';
        graphCanvas.style.display = '';
        multiplierEl.textContent = '1.00x';
        crashMsg.style.display = 'none';
        betBtn.style.display = '';
        betBtn.disabled = false;
        betBtn.textContent = myBet ? 'Ставка сделана' : 'Сделать ставку';
        cashoutBtn.style.display = 'none';
        betAmountInput.disabled = !!myBet;
        autoCashoutInput.disabled = !!myBet;
        if (gameState.status === 'starting') {
          let left = Math.max(0, Math.floor((gameState.nextStart - Date.now())/1000));
          statusBar.textContent = `До старта: ${left} сек`;
        } else {
          statusBar.textContent = 'Ожидание следующего раунда...';
        }
        myCashout = null;
        graphData = [];
        drawGraph();
      } else if (gameState.status === 'started') {
        if (joinedInRound && !gameState.players[userId]) {
          showWaitingRound();
        } else {
          waitingRoundDiv.style.display = 'none';
          graphCanvas.style.display = '';
          statusBar.textContent = 'Игра началась!';
          betBtn.style.display = 'none';
          cashoutBtn.style.display = '';
          cashoutBtn.disabled = !!myCashout;
          cashoutBtn.textContent = myCashout ? 'Забрано!' : 'Забрать';
          crashMsg.style.display = 'none';
          animateGraph();
        }
      } else if (gameState.status === 'crashed') {
        if (joinedInRound && !gameState.players[userId]) {
          showWaitingRound();
        } else {
          waitingRoundDiv.style.display = 'none';
          graphCanvas.style.display = '';
          statusBar.textContent = 'Игра окончена!';
          betBtn.style.display = '';
          betBtn.disabled = false;
          betBtn.textContent = 'Сделать ставку';
          cashoutBtn.style.display = 'none';
          crashMsg.style.display = '';
          setTimeout(() => { crashMsg.style.display = 'none'; }, 2000);
          drawGraph(true);
          // Выплата выигрыша если был кэшаут
          if (myBet && myCashout && myCashout <= gameState.crashAt) {
            const win = myBet * myCashout;
            balance += win;
            localStorage.setItem('crash_balance_' + userId, balance);
            updateBalanceUI();
          }
          myBet = null;
          myCashout = null;
          betAmountInput.disabled = false;
          autoCashoutInput.disabled = false;
        }
      }
    }
    function showWaitingRound() {
      waitingRoundDiv.style.display = '';
      waitingRoundDiv.textContent = 'Ожидание нового раунда';
      graphCanvas.style.display = 'none';
      multiplierEl.textContent = '';
      crashMsg.style.display = 'none';
      betBtn.style.display = '';
      betBtn.disabled = true;
      cashoutBtn.style.display = 'none';
      statusBar.textContent = 'Вы присоединились в уже идущем раунде';
    }
    function updatePlayersTable() {
      playersTbody.innerHTML = '';
      const players = gameState.players || {};
      Object.keys(players).forEach(uid => {
        const p = players[uid];
        const tr = document.createElement('tr');
        if (uid === userId) tr.classList.add('you');
        tr.innerHTML = `
          <td>${p.name || 'Гость'}${uid === userId ? ' <b>(Вы)</b>' : ''}</td>
          <td>${p.bet ? p.bet + '₽' : '-'}</td>
          <td>${p.auto ? p.auto + 'x' : '-'}</td>
          <td>${p.status === 'cashed' ? '<span style="color:var(--success)">Забрал</span>' : (p.status === 'crashed' ? '<span style="color:var(--danger)">Сгорел</span>' : '<span style="color:var(--accent)">Играет</span>')}</td>
          <td>${p.cashout ? (p.bet * p.cashout).toFixed(2) + '₽' : '-'}</td>
        `;
        playersTbody.appendChild(tr);
      });
    }

    // --- Graph ---
    function getMultiplier(time) {
      // Классическая формула Crash: multiplier = e^(0.00006 * t)
      return Math.floor(100 * Math.exp(0.00006 * time)) / 100;
    }
    function animateGraph() {
      if (gameState.status !== 'started') return;
      const now = Date.now();
      const elapsed = now - gameState.startTime;
      const mult = getMultiplier(elapsed);
      gameState.multiplier = mult;
      multiplierEl.textContent = mult.toFixed(2) + 'x';
      graphData.push({ t: elapsed, m: mult });
      drawGraph();
      // Автостоп
      if (myBet && !myCashout && myAutoCashout <= mult) {
        cashoutBtn.click();
      }
      graphAnimId = requestAnimationFrame(animateGraph);
    }
    function drawGraph(crashed) {
      ctx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
      // Оси
      ctx.strokeStyle = '#2c3145';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(40, graphCanvas.height - 30);
      ctx.lineTo(40, 20);
      ctx.moveTo(40, graphCanvas.height - 30);
      ctx.lineTo(graphCanvas.width - 10, graphCanvas.height - 30);
      ctx.stroke();
      // Подписи осей
      ctx.fillStyle = '#b0b8d1';
      ctx.font = '14px Montserrat';
      ctx.fillText('1x', 10, graphCanvas.height - 35);
      ctx.fillText('Время', graphCanvas.width - 60, graphCanvas.height - 10);
      // График
      if (graphData.length > 1) {
        // Масштабирование по времени и множителю
        let maxT = Math.max(...graphData.map(d => d.t), 10000);
        let maxM = Math.max(...graphData.map(d => d.m), 2);
        if (crashed) maxM = Math.max(maxM, gameState.crashAt);
        const xScale = (graphCanvas.width - 60) / maxT;
        const yScale = (graphCanvas.height - 60) / (maxM - 1);
        ctx.strokeStyle = crashed ? '#ff3b3b' : '#ffb300';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let i = 0; i < graphData.length; i++) {
          const x = 40 + graphData[i].t * xScale;
          const y = graphCanvas.height - 30 - (graphData[i].m - 1) * yScale;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        // Crash точка
        if (crashed && graphData.length > 1) {
          const last = graphData[graphData.length - 1];
          const x = 40 + last.t * xScale;
          const y = graphCanvas.height - 30 - (last.m - 1) * yScale;
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, 2 * Math.PI);
          ctx.fillStyle = '#ff3b3b';
          ctx.fill();
        }
      }
    }

    // --- Listen game state ---
    listenGameState();

    // --- Admin: Автоматический запуск раундов (только если никого нет ведущего) ---
    let isHost = false;
    function tryBecomeHost() {
      const hostRef = db.ref('crash/host');
      hostRef.transaction(current => {
        if (!current || current.ts < Date.now() - 20000) {
          return { id: userId, ts: Date.now() };
        }
        return current;
      }, (err, committed, snap) => {
        if (snap && snap.val() && snap.val().id === userId) {
          isHost = true;
          startHostLoop();
        }
      });
    }
    function startHostLoop() {
      setInterval(() => {
        db.ref('crash/state').once('value').then(snap => {
          const state = snap.val();
          if (!state || state.status === 'crashed' || state.status === 'waiting') {
            startRound();
          }
        });
      }, 1000);
    }
    function startRound() {
      const roundId = 'r_' + Date.now();
      const crashAt = (Math.random() * 10 + 1.5).toFixed(2); // 1.5x - 11.5x
      const nextStart = Date.now() + 10000;
      db.ref('crash/state').set({
        status: 'starting',
        startTime: 0,
        crashAt: parseFloat(crashAt),
        multiplier: 1.0,
        roundId: roundId,
        nextStart: nextStart
      });
      db.ref('crash/rounds/' + roundId).set({
        players: {}
      });
      // КД 10 секунд
      setTimeout(() => {
        db.ref('crash/state').update({
          status: 'waiting'
        });
        setTimeout(() => {
          db.ref('crash/state').update({
            status: 'started',
            startTime: Date.now(),
            multiplier: 1.0
          });
          runCrash(roundId, parseFloat(crashAt));
        }, 1000);
      }, 9000);
    }
    function runCrash(roundId, crashAt) {
      let running = true;
      let start = Date.now();
      function tick() {
        if (!running) return;
        const elapsed = Date.now() - start;
        const mult = getMultiplier(elapsed);
        if (mult >= crashAt) {
          running = false;
          db.ref('crash/state').update({
            status: 'crashed',
            multiplier: crashAt
          });
          // Обновить статусы игроков
          db.ref('crash/rounds/' + roundId + '/players').once('value').then(snap => {
            const players = snap.val() || {};
            Object.keys(players).forEach(uid => {
              if (!players[uid].cashout) {
                db.ref('crash/rounds/' + roundId + '/players/' + uid + '/status').set('crashed');
              }
            });
          });
          return;
        }
        db.ref('crash/state').update({
          multiplier: mult
        });
        setTimeout(tick, 50);
      }
      tick();
    }
    tryBecomeHost();

    // --- Не сбрасывать баланс при перезагрузке ---
    // window.onbeforeunload = () => {};

    // --- Таймер обновления статуса ---
    setInterval(() => {
      if (gameState.status === 'starting') {
        let left = Math.max(0, Math.floor((gameState.nextStart - Date.now())/1000));
        statusBar.textContent = `До старта: ${left} сек`;
      }
    }, 200);

  </script>
</body>
</html>
